"""
Cloud Deployer for Uatu Genesis Engine

Handles deployment of AI personas to Hugging Face Spaces.
This module performs actual cloud deployments, not simulations.

**OPERATIONAL CONTEXT:**
Converting local AI persona generators into cloud-deployment engines.
This code executes real uploads to Hugging Face Spaces.
"""
import os
import tempfile
from pathlib import Path
from typing import Optional
from huggingface_hub import HfApi
from huggingface_hub.utils import HfHubHTTPError


class AuthenticationError(Exception):
    """Raised when Hugging Face authentication fails."""
    pass


class CloudDeployer:
    """
    Cloud deployment engine for AI personas.
    
    Deploys AI personas to Hugging Face Spaces as containerized applications.
    """
    
    def __init__(self, hf_token: str):
        """
        Initialize CloudDeployer with Hugging Face authentication.
        
        Args:
            hf_token: Hugging Face API token
            
        Raises:
            AuthenticationError: If token is invalid
        """
        self.api = HfApi(token=hf_token)
        self.hf_token = hf_token
        
        # Validate token immediately
        try:
            self.user_info = self.api.whoami()
        except HfHubHTTPError as e:
            raise AuthenticationError(f"Invalid Hugging Face token: {e}")
        except Exception as e:
            raise AuthenticationError(f"Authentication failed: {e}")
    
    def _check_or_create_space(self, space_name: str) -> str:
        """
        Check if Space exists, create if it doesn't.
        
        Args:
            space_name: Full space name (e.g., 'username/space-name')
            
        Returns:
            Space ID (repo_id)
        """
        try:
            # Try to get space info
            space_info = self.api.space_info(repo_id=space_name)
            return space_info.id
        except HfHubHTTPError as e:
            # Space doesn't exist (404), create it
            if e.response.status_code == 404:
                space_info = self.api.create_repo(
                    repo_id=space_name,
                    repo_type="space",
                    space_sdk="docker",
                    exist_ok=True
                )
                return space_name
            else:
                # Other HTTP errors should be re-raised
                raise
    
    def _generate_launch_script(self, persona_path: str, original_launch_script: str) -> str:
        """
        Generate enhanced launch script with Genesis integration.
        
        This script handles:
        - Secure credential vault (local .env with auto-gitignore)
        - Avatar generation via Flux (first boot only)
        - Construct narrative loading
        - System context injection
        
        Args:
            persona_path: Relative path to persona directory
            original_launch_script: Name of the original launch script
            
        Returns:
            Launch script content as string
        """
        launch_script = f"""#!/usr/bin/env python3
\"\"\"
Enhanced Launch Script with Genesis Integration
Generated by Uatu Genesis Engine

Handles:
- Secure credential vault (local .env)
- Avatar generation via Flux (first boot)
- Construct narrative loading
- System context injection
\"\"\"
import sys
import os
import time
import logging
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Add agent-zero to path
agent_zero_path = Path(__file__).parent.parent.parent / "agent_zero_framework"
sys.path.insert(0, str(agent_zero_path))

def secure_boot_sequence():
    \"\"\"
    Handles secure credential injection via local .env vault.
    Ensures keys exist in memory but are not committed to git.
    \"\"\"
    print("\\n" + "="*60)
    print(" ðŸ›¡ï¸  GRIZZLY MEDICINE: SECURE BOOT PROTOCOL (V2.0)")
    print("="*60)
    
    # 1. Define Vault Paths
    # Navigate up from persona directory to repo root
    persona_dir = Path(__file__).parent
    agent_zero_dir = persona_dir.parent.parent
    repo_root = agent_zero_dir.parent
    vault_path = repo_root / ".env"
    
    # 2. Check for existing vault
    if vault_path.exists():
        print(">> DETECTED LOCAL VAULT (.env)")
        print(">> DECRYPTING CREDENTIALS...")
        
        # Use python-dotenv for robust parsing (handles quotes, escaping, etc.)
        try:
            from dotenv import dotenv_values
            env_vars = dotenv_values(vault_path)
            
            # Validate and inject environment variables
            count = 0
            allowed_keys = {{
                'OPENROUTER_API_KEY', 'HF_TOKEN', 'HUGGING_FACE_HUB_TOKEN',
                'GITHUB_TOKEN', 'CONVEX_URL', 'CONVEX_ADMIN_KEY'
            }}
            
            for key, value in env_vars.items():
                # Only load whitelisted keys for security
                if key in allowed_keys and value:
                    os.environ[key] = value
                    count += 1
            
            print(f">> {{count}} KEYS INJECTED SUCCESSFULLY.")
            time.sleep(1)
            return
        except ImportError:
            # Fallback to manual parsing if python-dotenv not available
            count = 0
            with open(vault_path, "r", encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # Skip empty lines and comments
                    if not line or line.startswith("#"):
                        continue
                    if "=" in line:
                        key, value = line.split("=", 1)
                        # Strip whitespace and remove quotes if present
                        key = key.strip()
                        value = value.strip().strip('"').strip("'")
                        # Validate key format (alphanumeric and underscores only)
                        if key and key.replace('_', '').isalnum():
                            os.environ[key] = value
                            count += 1
            
            print(f">> {{count}} KEYS INJECTED SUCCESSFULLY.")
            time.sleep(1)
            return

    # 3. First Run - Manual Entry
    print("\\n[FIRST RUN DETECTED - SYSTEM CONFIGURATION REQUIRED]")
    print("Please enter credentials. They will be saved locally to .env")
    print("and automatically added to .gitignore.\\n")
    
    # The Four Pillars
    or_key = input("1. OpenRouter Key (The Brain): ").strip()
    hf_key = input("2. Hugging Face Token (The Face): ").strip()
    gh_key = input("3. GitHub Token (The Hands): ").strip()
    
    print("\\n[CONVEX SETUP]")
    print("   Go to https://dashboard.convex.dev -> Create Project")
    print("   Settings -> URL & Deploy Key")
    convex_url = input("4. Convex Deployment URL (The Memory): ").strip()
    convex_key = input("5. Convex Admin Key (Optional - for Admin): ").strip()

    # Inject into current session immediately (only if non-empty)
    if or_key: os.environ["OPENROUTER_API_KEY"] = or_key
    if hf_key: 
        os.environ["HF_TOKEN"] = hf_key
        os.environ["HUGGING_FACE_HUB_TOKEN"] = hf_key
    if gh_key: os.environ["GITHUB_TOKEN"] = gh_key
    if convex_url: os.environ["CONVEX_URL"] = convex_url
    if convex_key: os.environ["CONVEX_ADMIN_KEY"] = convex_key

    # 4. Save to Vault
    save = input("\\n>> SAVE CREDENTIALS TO LOCAL VAULT (.env)? [Y/N]: ").strip().upper()
    if save == "Y":
        # Use python-dotenv for robust writing (handles escaping automatically)
        try:
            from dotenv import set_key
            
            # Write each credential safely with automatic escaping
            if or_key:
                set_key(vault_path, "OPENROUTER_API_KEY", or_key)
            if hf_key:
                set_key(vault_path, "HF_TOKEN", hf_key)
                set_key(vault_path, "HUGGING_FACE_HUB_TOKEN", hf_key)
            if gh_key:
                set_key(vault_path, "GITHUB_TOKEN", gh_key)
            if convex_url:
                set_key(vault_path, "CONVEX_URL", convex_url)
            if convex_key:
                set_key(vault_path, "CONVEX_ADMIN_KEY", convex_key)
                
            print(">> VAULT CREATED.")
        except ImportError:
            # Fallback to manual writing with proper escaping
            with open(vault_path, "w", encoding='utf-8') as f:
                # Escape double quotes in values
                if or_key:
                    escaped_val = or_key.replace('"', '\\\\"')
                    f.write(f'OPENROUTER_API_KEY="{{escaped_val}}"\\n')
                if hf_key:
                    escaped_val = hf_key.replace('"', '\\\\"')
                    f.write(f'HF_TOKEN="{{escaped_val}}"\\n')
                    f.write(f'HUGGING_FACE_HUB_TOKEN="{{escaped_val}}"\\n')
                if gh_key:
                    escaped_val = gh_key.replace('"', '\\\\"')
                    f.write(f'GITHUB_TOKEN="{{escaped_val}}"\\n')
                if convex_url:
                    escaped_val = convex_url.replace('"', '\\\\"')
                    f.write(f'CONVEX_URL="{{escaped_val}}"\\n')
                if convex_key:
                    escaped_val = convex_key.replace('"', '\\\\"')
                    f.write(f'CONVEX_ADMIN_KEY="{{escaped_val}}"\\n')
            
            print(">> VAULT CREATED.")

        # 5. Secure the Vault (Update .gitignore)
        gitignore_path = repo_root / ".gitignore"
        if gitignore_path.exists():
            with open(gitignore_path, "r", encoding='utf-8') as f:
                content = f.read()
            # Check if .env is already in gitignore (look for uncommented lines)
            lines = content.split('\\n')
            has_env = False
            for line in lines:
                stripped = line.strip()
                # Skip comments
                if stripped.startswith('#'):
                    continue
                # Check for .env patterns (with or without leading slash/wildcards)
                if stripped in ['.env', '*.env', '**/.env', '/.env']:
                    has_env = True
                    break
            if not has_env:
                with open(gitignore_path, "a", encoding='utf-8') as f:
                    f.write("\\n# Local Credential Vault\\n.env\\n")
                print(">> .env ADDED TO .gitignore (SAFE FROM UPLOAD)")
        else:
            # Create gitignore if missing
            with open(gitignore_path, "w", encoding='utf-8') as f:
                f.write(".env\\n")
            print(">> .gitignore CREATED.")
            
    else:
        print(">> WARNING: RUNNING IN EPHEMERAL MODE. KEYS WILL VANISH ON EXIT.")

    print("\\n>> SYSTEMS ONLINE. WAKING DIGITAL PERSON...")
    time.sleep(2)

def genesis_sequence():
    \"\"\"Execute the Genesis Sequence (first boot initialization).\"\"\"
    try:
        # Check for avatar
        avatar_path = Path("/app/persona_data/avatar.png")
        if not avatar_path.exists():
            logger.info(">> GENESIS SEQUENCE: FORGING PHYSICAL FORM VIA FLUX...")
            
            try:
                from python.helpers.rsi_generator import ensure_avatar_exists
                success = ensure_avatar_exists(
                    persona_path="{persona_path}"
                )
                if success:
                    logger.info(">> AVATAR FORGED SUCCESSFULLY")
                else:
                    logger.warning(">> AVATAR GENERATION FAILED (CONTINUING WITHOUT AVATAR)")
            except Exception as e:
                logger.error(f">> AVATAR GENERATION ERROR: {{e}}")
                logger.warning(">> CONTINUING WITHOUT AVATAR")
        else:
            logger.info(">> AVATAR EXISTS: GENESIS COMPLETE")
        
        # Load construct narrative if it exists
        construct_path = Path(__file__).parent / "construct.txt"
        if construct_path.exists():
            logger.info(">> LOADING CONSTRUCT NARRATIVE...")
            construct_text = construct_path.read_text()
            
            # Store in environment for agent context initialization
            os.environ["CONSTRUCT_NARRATIVE"] = construct_text
            logger.info(">> CONSTRUCT NARRATIVE LOADED INTO SYSTEM CONTEXT")
        else:
            logger.info(">> NO CONSTRUCT NARRATIVE FOUND (OPTIONAL)")
            
    except Exception as e:
        logger.error(f"Genesis Sequence Error: {{e}}")
        logger.warning("Continuing with launch despite errors...")

# Set persona-specific environment
os.environ["AGENT_PROMPTS_DIR"] = str(Path(__file__).parent / "prompts")
os.environ["WORKSHOP_PERSONA_LOCKED"] = "true"

# Execute Secure Boot Sequence FIRST
secure_boot_sequence()

# Verify critical credentials exist
if "OPENROUTER_API_KEY" not in os.environ:
    logger.error("CRITICAL: OPENROUTER_API_KEY not found in environment")
    logger.error("The persona cannot think without OpenRouter API access")
    sys.exit(1)

if "HUGGING_FACE_HUB_TOKEN" not in os.environ and "HF_TOKEN" not in os.environ:
    logger.warning("WARNING: HUGGING_FACE_HUB_TOKEN not found")
    logger.warning("Some features may be limited without Hugging Face access")

# Execute Genesis Sequence
genesis_sequence()

# Import and run agent zero
try:
    from run_ui import run
    
    logger.info("=" * 80)
    logger.info("âš™ THE WORKSHOP - GrizzlyMedicine R&D")
    logger.info("=" * 80)
    logger.info(f"Digital Person: Initializing from {persona_path}")
    logger.info(f"Container Status: DEDICATED (No persona switching)")
    logger.info("=" * 80)
    
    # Launch the UI
    run()
    
except ImportError as e:
    logger.error(f"Error importing agent-zero: {{e}}")
    logger.error("Make sure agent-zero dependencies are installed:")
    logger.error("  pip install -r agent_zero_framework/requirements.txt")
    sys.exit(1)
except Exception as e:
    logger.error(f"Error launching: {{e}}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
"""
        return launch_script
    
    def _generate_dockerfile(self, persona_path: str, launch_script: str) -> str:
        """
        Generate Dockerfile for persona deployment.
        
        Args:
            persona_path: Relative path to persona directory (e.g., 'personas/lucius_fox')
            launch_script: Name of the launch script (e.g., 'launch_lucius_fox.py')
            
        Returns:
            Dockerfile content as string
        """
        dockerfile = f"""FROM python:3.10

# Set working directory
WORKDIR /app

# Copy persona files
COPY {persona_path} /app/{persona_path}

# Copy agent zero framework
COPY agent_zero_framework /app/agent_zero_framework

# Copy requirements
COPY requirements.txt /app/requirements.txt
COPY agent_zero_framework/requirements.txt /app/agent_zero_framework_requirements.txt

# Install system dependencies (audio drivers and build tools)
RUN apt-get update && apt-get install -y --no-install-recommends \\
    ffmpeg libsndfile1 libportaudio2 git build-essential \\
    && rm -rf /var/lib/apt/lists/*

# Install dependencies
RUN pip install --no-cache-dir -r /app/requirements.txt
RUN pip install --no-cache-dir -r /app/agent_zero_framework_requirements.txt

# Replace default prompts with persona prompts (Persona Identity Injection)
RUN rm -rf /app/agent_zero_framework/agents/agent0/prompts/*
COPY {persona_path}/prompts/ /app/agent_zero_framework/agents/agent0/prompts/

# Copy the genesis launch script
COPY genesis_launch.py /app/{persona_path}/genesis_launch.py

# Expose Hugging Face default port
EXPOSE 7860

# Set environment variable for Hugging Face Spaces
ENV GRADIO_SERVER_NAME="0.0.0.0"
ENV GRADIO_SERVER_PORT=7860

# Run the genesis launch script
CMD ["python", "/app/{persona_path}/genesis_launch.py"]
"""
        return dockerfile
    
    def deploy_persona(
        self, 
        persona_path: str, 
        token: Optional[str] = None, 
        target_space_name: Optional[str] = None
    ) -> str:
        """
        Deploy a persona to Hugging Face Spaces.
        
        This method performs the actual deployment:
        1. Validates authentication
        2. Creates or verifies the Space
        3. Generates Dockerfile
        4. Uploads all required files
        
        Args:
            persona_path: Path to persona directory (e.g., 'agent_zero_framework/personas/lucius_fox')
            token: Optional override token (uses instance token if None)
            target_space_name: Target space name (e.g., 'username/Lucius-Fox-Node')
                              If None, auto-generates from persona name
            
        Returns:
            URL of the deployed Space
            
        Raises:
            ValueError: If persona path doesn't exist
            AuthenticationError: If authentication fails
        """
        # Use provided token or instance token
        if token:
            # Validate new token
            try:
                api = HfApi(token=token)
                user_info = api.whoami()
            except Exception as e:
                raise AuthenticationError(f"Invalid token: {e}")
        else:
            api = self.api
            user_info = self.user_info
        
        # Validate persona path
        full_persona_path = Path(persona_path)
        if not full_persona_path.exists():
            raise ValueError(f"Persona path does not exist: {persona_path}")
        
        # Get persona name from path
        persona_name = full_persona_path.name
        
        # Generate space name if not provided
        if not target_space_name:
            username = user_info.get('name') or user_info.get('id')
            target_space_name = f"{username}/{persona_name.replace('_', '-').title()}-Node"
        
        # Check or create space
        space_id = self._check_or_create_space(target_space_name)
        
        # Find launch script
        launch_scripts = list(full_persona_path.glob("launch_*.py"))
        if not launch_scripts:
            raise ValueError(f"No launch script found in {persona_path}")
        launch_script = launch_scripts[0].name
        
        # Generate Dockerfile
        # Use relative path for Dockerfile
        rel_persona_path = str(full_persona_path)
        dockerfile_content = self._generate_dockerfile(rel_persona_path, launch_script)
        
        # Create temporary Dockerfile using secure tempfile
        temp_dockerfile = None
        try:
            # Use tempfile for secure cross-platform temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.Dockerfile', delete=False) as tf:
                tf.write(dockerfile_content)
                temp_dockerfile = Path(tf.name)
            
            # Get repo root (assumes we're running from repo root or subdirectory)
            repo_root = Path.cwd()
            if not (repo_root / "uatu_genesis_engine").exists():
                # Try parent directories
                for parent in Path.cwd().parents:
                    if (parent / "uatu_genesis_engine").exists():
                        repo_root = parent
                        break
            
            # Upload Dockerfile
            api.upload_file(
                path_or_fileobj=str(temp_dockerfile),
                path_in_repo="Dockerfile",
                repo_id=space_id,
                repo_type="space"
            )
        finally:
            # Clean up temp file
            if temp_dockerfile and temp_dockerfile.exists():
                temp_dockerfile.unlink()
        
        # Generate and upload genesis_launch.py
        genesis_script_content = self._generate_launch_script(rel_persona_path, launch_script)
        temp_genesis_script = None
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tf:
                tf.write(genesis_script_content)
                temp_genesis_script = Path(tf.name)
            
            # Upload genesis launch script
            api.upload_file(
                path_or_fileobj=str(temp_genesis_script),
                path_in_repo="genesis_launch.py",
                repo_id=space_id,
                repo_type="space"
            )
        finally:
            # Clean up temp file
            if temp_genesis_script and temp_genesis_script.exists():
                temp_genesis_script.unlink()
        
        # Upload persona directory
        api.upload_folder(
            folder_path=str(full_persona_path),
            path_in_repo=rel_persona_path,
            repo_id=space_id,
            repo_type="space"
        )
        
        # Upload agent_zero_framework
        agent_zero_path = repo_root / "agent_zero_framework"
        if agent_zero_path.exists():
            api.upload_folder(
                folder_path=str(agent_zero_path),
                path_in_repo="agent_zero_framework",
                repo_id=space_id,
                repo_type="space",
                ignore_patterns=[".*", "__pycache__", "*.pyc", "logs/", "memory/", "tmp/", "usr/"]
            )
        
        # Upload requirements.txt from repo root
        requirements_path = repo_root / "requirements.txt"
        if requirements_path.exists():
            api.upload_file(
                path_or_fileobj=str(requirements_path),
                path_in_repo="requirements.txt",
                repo_id=space_id,
                repo_type="space"
            )
        
        # Upload agent_zero requirements if it exists
        agent_zero_requirements = agent_zero_path / "requirements.txt"
        if agent_zero_requirements.exists():
            api.upload_file(
                path_or_fileobj=str(agent_zero_requirements),
                path_in_repo="agent_zero_framework/requirements.txt",
                repo_id=space_id,
                repo_type="space"
            )
        
        # Return Space URL
        space_url = f"https://huggingface.co/spaces/{space_id}"
        return space_url
